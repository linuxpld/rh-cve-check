#!/usr/bin/python

#==============================================================================
#title           : cve-affected.py
#description     : This script will take a CVE and print a plain english version 
#                  of it's BZ whiteboard.
#author          : coty
#date            : 20141214
#version         : 0.1
#usage           : python rh-cve-check.py CVE-2014-0001
#notes           : Note that the whiteboard is just that, a working notes area.
#                  It is a place that SRT keeps notes, so the only thing that
#                  is set in stone are errata that are released to fix things.
#==============================================================================

# Import the modules needed to run the script.
import urllib2
import re
import sys
import argparse

# Wrap BS loading to ensure it exists.
try:
    from BeautifulSoup import BeautifulSoup
except ImportError:
    print "BeautifulSoup is not installed and is a required dependency"
    sys.exit(1)

class bcolors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKGREEN = '\033[92m'
    WARN = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

# method to open URLs and encapsulate error handling
def openURL(url):
    try:
        # print "Reading " + url 
        return urllib2.urlopen(url)
    except urllib2.HTTPError, e:
        print "There was an http error retrieving the url (%s). Status code: %s" % (url, e.code)
    except urllib2.URLError, e:
        print "There was an url error retrieving the url (%s). Status code: %s" % (url, e.reason)

def parseCVEPage(cve_raw):
    # bumping case to upper case because it does matter for the URL
    cve = cve_raw.upper()

    bz_url = None

    # parse CVE page response
    cve_url = 'https://access.redhat.com/security/cve/' + cve
    cve_html = openURL(cve_url)
    cve_soup = BeautifulSoup(cve_html)

    # if the "CVE not found" header is found in the response, then the CVE provided DNE
    for h1_tag in cve_soup.findAll('h1'):
        if h1_tag.text == 'CVE not found':
            print "The CVE provided (%s) does not exist in the Red Hat CVE Database." % cve
            sys.exit()

    # grab CVE impact and any errata that it has
    cveData = parseImpactAndErrata(cve_soup)
    # add the CVE to the available data dictionary
    cveData['CVE Info']['CVE'] = cve
     
    # otherwise, parse all links on the page for the BZ link
    for link_tag in cve_soup.findAll('a', href=True):
        link = link_tag['href']
        link = link.encode('utf-8')

        if 'https://bugzilla.redhat.com/show_bug.cgi?id=' in link:
            bz_url = link
            break
    
    # if there is no BZ link, then exit
    if bz_url is None:
        print "There was no Bugzilla link found on %s" % cve_url
        sys.exit()

    # adding a method call to make it a bit easier to read
    bzData = parseBZPage(bz_url)

    # grab what we want from the two data sets and print it all pretty like
    printOutput(cveData, bzData)

def parseImpactAndErrata(cve_soup):
    ''' Method to find Ipmact and Errata on the CVE page '''
    cveData = {}

    tables = cve_soup.findAll('table') 
    for table in tables:      
        header = []
        information = {} 

        rows = table.findAll('tr')
        for tr in rows: 
            headings = tr.findAll('th')
            for th in headings:
                 header.append(th.find(text=True))
      
            if 'Platform' in header:
                temp_errata = {}

                i = 0
                data = tr.findAll('td')
                for td in data:
                    # grab the link if one exists
                    a = td.find('a') 
                    link = None
                    if a is not None:
                        link = a.get('href')

                    if link is not None:
                        temp_errata[header[i]] = link
                    else:
                        temp_errata[header[i]] = td.find(text=True)

                    i += 1
                    
                try:
                    cveData['Errata'].append(temp_errata)
                except Exception, e:
                    cveData['Errata'] = []
                    if (len(temp_errata) > 0):
                        cveData['Errata'].append(temp_errata)
            else: 
                # the platform table is the only one that can count the header columns
                headings = tr.findAll('th')
                for th in headings:
                     head = th.find(text=True)

                data = tr.findAll('td')
                for td in data:
                    information[head] = td.find(text=True)

        try:
            information['Impact:']
            cveData['CVE Info'] = information
        except Exception:
            pass
     
        try:
            information['Base Score:']
            cveData['CVSS v2 metrics'] = information
        except Exception:
            pass
       
    # print cveData 
    return cveData
        
def parseBZPage(bz_url):
    whiteboard = None
    bzData = []
     
    # parse BZ page response
    bz_html = openURL(bz_url)
    bz_soup = BeautifulSoup(bz_html)

    # since the whiteboard isn't actually in the response, parse all spans for one
    # including the usual starting item, 'impact'
    for span in bz_soup.findAll('span', title=re.compile('impact')):
        whiteboard = span['title'].split(',')
        break
    
    # after we have the whiteboard, parse through it
    for line in whiteboard:
        # split the lines by / to determine product and package
        # example response here: fedora-all/mariadb=affected
        product_package = line.split('/')
        product = product_package[0]
    
        # parsing these guys out and skipping them as I have no current use for this info. 
        # did it this way in case I wanted to use them in the future.
        if 'impact' in product:
            continue
        if 'public' in product:
            continue
        if 'reported' in product:
            continue
        if 'source' in product:
            continue
        if 'cvss' in product:
            continue
        if 'cwe' in product:
            continue
    
        # try spliting out the package and status.
        # example here is: mariadb=affected
        try:    
            package_status = product_package[1].split('=')
            package = package_status[0]
            status = package_status[1]
        except Exception as e:
            # if this fails, then it is likely not a product and should be added to the list above with impact, source, etc
            # print this as a warning and keep going since it wouldn't cause any failure
            print "WARN: There was an %s whie processing %s. Message: %s" % (type(e), product_package, e)
    
        bzData.append({'product': product, 'package': package, 'status': status})

    # print bzData
    return bzData

def printOutput(cveData, bzData):
    print "CVE: %s " % cveData['CVE Info']['CVE']
    print "Impact: %s " % cveData['CVE Info']['Impact:']

    errata_list = {}
    for errata in cveData['Errata']:
        try:
            short_name = decomposeProductAndPackage(errata['Platform'])
            errata_list[short_name] = errata['Errata']
        except Exception:
            pass

    for rec in bzData:
        product = rec['product']
        package = rec['package']
        status = rec['status']
        errata = ""

        # print the package and status info!
        # TODO: prettify this output some? E.g. change status 'notaffected' to 'not affected', etc?
        #print "The \'%s\' package provided by \'%s\' is \'%s\'." % (package, product, status)

        # attempting colorizing :D
        if (status == 'affected'):
            status = bcolors.FAIL + status + bcolors.ENDC
        elif (status == 'notaffected'):
            status = bcolors.OKGREEN + status + bcolors.ENDC
        elif (status == 'fixed'):
            status = bcolors.WARN + status + bcolors.ENDC
       
        if ('affected' in status and product in errata_list):
            print "The \'%s\' package provided by \'%s\' is \'%s\', however there is an erratum to resolve the issue here: %s" % (package, product, status, errata_list[product])
        else:
            print "The \'%s\' package provided by \'%s\' is \'%s\'." % (package, product, status)

def decomposeProductAndPackage(platform):
    if platform is None:
        raise Exception("Platform '%s' is None!" % platform)

    # Red Hat Enterprise Linux version 5 (httpd)
    matcher = re.search('Red Hat Enterprise Linux version ([0-9]+) \(([a-zA-Z0-9]+)\)', platform)
    if matcher is not None:
        return 'rhel-%s' % matcher.group(1) # product
        # print matcher.group(2) # package
    
    # Red Hat JBoss Enterprise Application Platform 6.0 
    matcher = re.search('Red Hat JBoss Enterprise Application Platform ([0-9]+)', platform)
    if matcher is not None:
        return 'eap-%s' % matcher.group(1)
    
    # Red Hat JBoss Web Server 2.1
    matcher = re.search('Red Hat JBoss Web Server ([0-9]+)', platform)
    if matcher is not None:
        return 'jbews-%s' % matcher.group(1)

    # Red Hat JBoss Operations Network 3.3
    matcher = re.search('Red Hat JBoss Operations Network ([0-9]+)', platform)
    if matcher is not None:
        return 'jon-%s' % matcher.group(1)

    raise Exception("Platform '%s' not found!" % platform)

def set_args(parser):
    parser.add_argument('cves', metavar='CVE', nargs='+',
        help="List of CVE's you would like to get a report on.")
    return parser.parse_args()

def main():
    parser = argparse.ArgumentParser(description="Check one or multiple CVE's aginst Red Hat's CVE database.")
    args = set_args(parser)

    for cve in args.cves:
        parseCVEPage(cve)

if __name__ == "__main__":
    main()
